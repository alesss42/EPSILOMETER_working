function [Pv,Pv_co,fe]=multivariate_correction(signal2correct,vibration,nfft,Fs)
% Correcting the shear channels using a multivariate acceleration
% correction: I use all the acceleration channnels to get a combined
% coherence that removed from the shear channel. 
%
% Input: signaltocorrect: 1D timeseries of the signal you want to correct
%        vibration      : 2D (channels,timestamp) timseries of "vibrations"
%                         you want to use to correct signaltocorrect  
%        
% Compute the coherence over the whole profile using all 3 axis (we could add more) 
% over the 1./tsan:Fs frequency frequency axis with nfft samples.

% written by aleboyer@ucsd.edu 10/01/2021

% when the probes are oriented down/upward
% a3 should be alingned with the shear
% a1 is the other horizontal accell
% a2 is the vertical 

% detrend signal to correct beffo
signal2correct=detrend(signal2correct)

if size(vibration,2)>size(vibration,1)
    vibration=vibration.';
end

nb_vibration_channel=size(vibration,1);

Csi=zeros(nb_vibration_channel,nfft/2+1);
Csj=zeros(nb_vibration_channel,nfft/2+1);
Aij=zeros(nb_vibration_channel,nb_vibration_channel,nfft/2+1);
MC=zeros(nb_vibration_channel,nb_vibration_channel,nfft/2+1);

df=Fs./nfft;
    % lets do this 
    [Pv,fe]=pwelch(detrend(signal2correct),nfft,[],nfft,Fs);

    for i=1:nb_vibration_channel% nb of accel channel
        accel_i=detrend(scan.(wh_accel_i));
        Csi(i,:)=cpsd(detrend(scan.s1_volt), accel_i,...
                      nfft,[],nfft,Fs);

        for j=1:nb_accel_channel %nb of accel channel
            wh_accel_j=list_accel{i};
            accel_j=detrend(scan.(wh_accel_j));

            Csj(j,:)=cpsd(detrend(scan.s1_volt), accel_j,...
                nfft,[],nfft,Fs);

            Aij(i,j,:)=cpsd(accel_i,accel_j, ...
                            nfft,[],nfft,Fs);
                        
            MC(i,j,:)=Csi(i,:).*conj(Csj(j,:))./ ...
                      squeeze(Aij(i,j,:)).';
            
        end  
    end
    % sum the MC (Mutlivariate Coeficients to get the correction)
    % Not sure about the df. It is in the Goodman2006 paper but I have a
    % doubt wether it is already included in the output of cpsd. 
    % With the df It seems to do a good job in the correction.
    Coh=squeeze(nansum(nansum(MC,1),2))*df;      
    Pv1_co=Pv1-Coh;
  
end

if isfinite(scan.s2_volt)
    % lets do this 
    [Pv2,~]=pwelch(detrend(scan.s2_volt),nfft,[],nfft,Fs);

    for i=1:nb_accel_channel% nb of accel channel
        wh_accel_i=list_accel{i};
        accel_i=detrend(scan.(wh_accel_i));
        Csi(i,:)=cpsd(detrend(scan.s2_volt), accel_i,...
                      nfft,[],nfft,Fs);

        for j=1:nb_accel_channel %nb of accel channel
            wh_accel_j=list_accel{i};
            accel_j=detrend(scan.(wh_accel_j));

            Csj(j,:)=cpsd(detrend(scan.s2_volt), accel_j,...
                nfft,[],nfft,Fs);

            Aij(i,j,:)=cpsd(accel_i,accel_j, ...
                            nfft,[],nfft,Fs);
                        
            MC(i,j,:)=Csi(i,:).*conj(Csj(j,:))./ ...
                      squeeze(Aij(i,j,:)).';
            
        end  
    end
    % sum the MC (Mutlivariate Coeficients to get the correction)
    % Not sure about the df. It is in the Goodman2006 paper but I have a
    % doubt wether it is already included in the output of cpsd. 
    % With the df It seems to do a good job in the correction.
    Coh=squeeze(nansum(nansum(MC,1),2))*df;      
    Pv2_co=Pv2-Coh;
end